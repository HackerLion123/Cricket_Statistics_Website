



























                                        
            
    
        
        
        
    
    
        
        
        
    
    
    




    
                                
    
	
	       	
       	                                						
	

/** Helper and system settings methods **/ var utils={ JsonToString: function (jStr) { var i, strOut=''; for (i in jStr) { if (jStr.hasOwnProperty(i)) { strOut += i + '=' + jStr[i] + '&'; } } return strOut.substring(0, strOut.length - 1); }, isNotNullOrUndefined: function (obj) { return typeof obj !== "undefined" && obj !== "" && obj !== null; }, isString: function (s) { return typeof s=== "string"; }, isNumber: function (s) { return typeof s=== "number"; }, isChrome: function() { return navigator.userAgent.toLowerCase().indexOf('chrome') > -1; }, isFirefox: function() { return navigator.userAgent.toLowerCase().indexOf('firefox') > -1; }, getScript: function(_url, _ff, _iExt){ var oScript=document.createElement("script"), oHead=document.getElementsByTagName("head")[0]; oScript.setAttribute("type", "text/javascript"); oScript.setAttribute("language", "javscript"); oScript.setAttribute("src", _url+(!_iExt?".js":"")); oHead.appendChild(oScript); if (oScript.readyState) { oScript.onreadystatechange = function () { if ((this.readyState == 'complete' || this.readyState == 'loaded') && typeof _ff=== 'function') { _ff(oScript); } } } else { if (typeof _ff== 'function') { oScript.onload = function() { _ff(oScript) }; } } }, scriptLoader: function(_dependencies, _onLoaded) { try { if (_dependencies.length === 0) { LOGGER.log('scriptLoader::loading completed'); return _onLoaded(); } else { var script=_dependencies.shift(); /* import script if object is undefined */ if (typeof window[script.name] === "undefined") { LOGGER.log('scriptLoader::loading ' + script.name + ' - ' + script.url); utils.getScript(script.url, function (data, textStatus, jqxhr) { return utils.scriptLoader(_dependencies, _onLoaded); }, true); } else { LOGGER.log('scriptLoader::skipped inject - ' + script.name + ' object exist '); return utils.scriptLoader(_dependencies, _onLoaded); } } } catch (e) { LOGGER.log('scriptLoader::' + e.message); } }, isTooltabInstalled: function(_data, _cobrand, _onTooltabDetect) { try { var ttDetectUtil=window['ttDetectUtil'], onToolTabDetect=function() { var oTooltabData={bTooltabInstalled: false}; LOGGER.log(_data.status + "::ttabDetect completed - trigger init callback"); if (utils.isNotNullOrUndefined(ttDetectUtil.ttDetectData) && ttDetectUtil.ttDetectData.hit_count) { ttDetectUtil.ttDetectData.bTooltabInstalled = ttDetectUtil.ttDetectData.hit_count > 0; oTooltabData = ttDetectUtil.ttDetectData; } if (typeof _onTooltabDetect === "function") { _onTooltabDetect(oTooltabData); } }; ttDetectUtil.getData(_cobrand, onToolTabDetect); } catch (e) { LOGGER.log('isTooltabInstalled::' + e.message); } }, hasLocalStorage: function() { try { if(typeof(localStorage) == "object") { localStorage.setItem("test", "test"); localStorage.removeItem("test"); return true; } return false; } catch (exception) { return false; } }, /** Inject Chrome Web Store Item given URL **/ appendCWSItem: function (linkURL) { var oLink = document.getElementById("chrome-webstore-item"), oHead = document.getElementsByTagName("head")[0]; if (!oLink) { oLink = document.createElement("link"), oLink.setAttribute("id", "chrome-webstore-item"); oLink.setAttribute("rel", "chrome-webstore-item"); oLink.setAttribute("href", linkURL); oHead.appendChild(oLink); } }, validateAbsolutePathUrl: function(_url) { var sCurrPathName= location.pathname.substring(0,location.pathname.lastIndexOf("/")+1); var url = _url; if (url.indexOf("http:") != 0) { url = 'http://'+location.hostname+sCurrPathName.substring(0,sCurrPathName.lastIndexOf("/")+1) + url; } return url; }, convertToDynamicMSNIExe: function(_exe,_tbId) { var dynExe_fullurl = ""; if (_exe != "") { var dynExe_path = _exe.substring(0,_exe.lastIndexOf("/")); var dynExe_filename_full = _exe.substring(_exe.lastIndexOf("/") + 1, _exe.lastIndexOf(".")); var dynExe_filename = dynExe_filename_full.substring(0, dynExe_filename_full.lastIndexOf(".")); dynExe_fullurl = dynExe_path + "/msni" + dynExe_filename_full + "/" + dynExe_filename_full; if(_tbId) { dynExe_fullurl += "." + _tbId; } dynExe_fullurl += ".exe"; } return dynExe_fullurl; }, install: function(fileName) { LOGGER.log('install::' + fileName); try { if (!utils.isNotNullOrUndefined(fileName)) { LOGGER.log('install::Missing installer URL!'); return false; } var fileLoader = document.createElement('iframe'); fileLoader.src = fileName; fileLoader.style.display = 'none'; document.body.appendChild(fileLoader); } catch(e) { LOGGER.error('Offsite JS', e.message); return false; } return true; }, /* Fetch parameter from URL query string */ getParam: function (name, src) { if (!this.isNotNullOrUndefined(src)) { src = location.href; } name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]"); var regexS = "[\\?&]"+name+"=([^&#]*)", regex = new RegExp(regexS), matches = regex.exec(src); return this.isNotNullOrUndefined(matches) ? matches[1] : null; }, /* Generate query string given parameters */ generateQueryStr: function (oParams) { var p, v, aParams = []; if (!this.isNotNullOrUndefined(oParams)) { return ""; } /* Collect URL Parameters */ for (p in oParams) { if (oParams.hasOwnProperty(p)) { v = oParams[p]; if (this.isNotNullOrUndefined(v)) { aParams.push(p + "=" + v); } else { try { delete oParams[p]; } catch(e) {} } } } return "?" + aParams.join('&'); }, getElementsByClassName: function(strClassName, oElm, strTagName){ if (typeof (oElm) === "undefined") oElm = document; if (typeof (strTagName) === "undefined") strTagName = "div"; var arrElements = (strTagName === "*" && oElm.all)? oElm.all : oElm.getElementsByTagName(strTagName), arrReturnElements = new Array(), strClassName = strClassName.replace(/\-/g, "\\-"), oRegExp = new RegExp("(^|\\s)" + strClassName + "(\\s|$)"), oElement, i; for (i=0; i<arrElements.length; i++){ oElement=arrElements[i]; if (oElement.className !== "") { if (oRegExp.test(oElement.className)){ arrReturnElements.push(oElement); } } } return (arrReturnElements) } }; /** Handles pixel tracking **/ var unifiedLogging={ enabled: false, errCount: 0, src: '//ak.imgfarm.com/images/anx/anemone-1.2.7.js', events: { ToolbarDetect: "ToolbarDetect", SplashLanding: "SplashLanding", SplashLandingClicked: "SplashLandingClicked", InstallerInvoked: "InstallerInvoked", InstallerAccepted: "InstallerAccepted", InstallerFinished: "InstallerFinished", PixelFrameTB: "PixelFrameTB", UIControl: "UIControl", PageRedirect: "PageRedirect", Error: "Error" }, /* Value will be driven by SearchExtensionURLOverrideAttribute from results */ allowSearchExtensionURLParamsOverride: false, /* Replacement events */ searchExtensionEventTypes: { "SplashLanding": "3rdPartyOfferShow", "SplashLandingClicked": "3rdPartyOfferClicked", "Error": '3rdPartyOfferError', "InstallerAccepted": "3rdPartyOfferAccept", "InstallerRebuttal": "3rdPartyOfferRebuttal", "InstallerFinished": "3rdPartyOfferDownloadComplete" }, section: "external", load: function(cb) { this.enabled = ( typeof(_Anemone) !== 'undefined' ); /* if _Anemone is missing load it dynamically */ if (!this.enabled) { utils.getScript(this.src, function(data, textStatus, jqxhr) { cb(); }, true); return false; } else { _Anemone.logPageView(); } return true; }, /* Param aggregate & trigger * @param evtType - event name * @param evtParams - event params * @param cb - triggered after pixel is sent */ /* Param aggregate & trigger * @param name - event name * @param params - anemone params * @params opt - optional app params such as section, cookies enabled, campaignVal, etc... */ logEvent: function(name, params, cookieOpt, cb){ if (this.enabled) { if (this.events[ name ] !== null) { var anemone_params=params; if (name === this.events.Error) { this.errCount++; } /* log initial error event */ if (this.errCount> 1) { return false; } if (this.allowSearchExtensionURLParamsOverride) { if (this.searchExtensionEventTypes[name] != null) { name=this.searchExtensionEventTypes[name]; } else { return; } } /* trigger event */ if (utils.isNotNullOrUndefined(anemone_params)) { _Anemone.logEvent(name, anemone_params, function(result) { if (typeof cb=== "function") cb(result); }); } else { _Anemone.logEvent(name), {}, function(result) { if (typeof cb=== "function") cb(result); }; } } } return false; } }; /** For Debugging **/ var LOGGER={ oConsole: null, log: function (oMsg, clr) { if (!utils.isNotNullOrUndefined(_dlpOffsite.log) || !_dlpOffsite.log) { return false; } if (utils.isNotNullOrUndefined(this.oConsole)) { this.oConsole = document.getElementById("console"); this.oConsole.style.display = document.getElementById("clearBtn").style.display = "block"; } if (typeof oMsg !== "string") { oMsg=utils.JsonToString(oMsg); } if (!utils.isNotNullOrUndefined(oMsg)) { return false; } if (utils.isNotNullOrUndefined(LOGGER.oConsole)) { this.oConsole.value = !clr ? (LOGGER.oConsole.value + "> " + oMsg + "\n\n") : ("> " + oMsg + "\n"); } else if (utils.isNotNullOrUndefined(window.console)) { try { console.log(oMsg); } catch(e){} } }, error: function (code, type, cb) { if (typeof cb !== "function") { cb = function() { LOGGER.log({code: code, type: type}); }; } if (typeof unifiedLogging == "undefined") { return false; } unifiedLogging.logEvent(unifiedLogging.events.Error, { errorCode: code, errorType: type }, cb); } }; var _AnemoneParams = { appId: "CAPDownloadProcess", appVersion: "1.0.0", appDate: "2011-06-01T04:00:00Z", uniqueUser: "", coid: "ce809b875f584962b0c4554a23d3c150", logPageView: false, updateSession: true, url: "//anx.mindspark.com/tr.gif", getAppParams: function() { var appParams = { anxs: "external", lang: "en", platform: "vicinio", installerType: "CRX_WEBSTORE", refPartner: "^CTT^prs001^B2BMS^in", paidPartner: "^CTT^prs001^B2BMS^in", isGCLID: "false", throughput: "vhigh", userExperienceRevision: "1", refCobrand: "CTT", refSub: "0hr434520000102356142868C437C359A2A2917EADF4FC72DA4FB6a----------------------------14313374183u__3", refCampaign: "prs001", refTrack: "B2BMS", refCountry: "in", coid: "ce809b875f584962b0c4554a23d3c150", tbGuid: "E7D2242A-CB05-4DFB-ABBA-BD8CCE4F9C0C", anxsn: "dfprdsndlbfe64.df.jabodo.com" }; return appParams; } }; try { var Installer = /** @ignore */ function(config) { "use strict"; var document = window.document; var installer = function() { var bTooltabDetected = false; var bTooltabInstalled = false; var partnerIdString = "^CTT^prs001^B2BMS^in"; var subIdString = "0hr434520000102356142868C437C359A2A2917EADF4FC72DA4FB6a----------------------------14313374183u__3"; var tooltabId = 235543481 ; /* * Date Format 1.2.3 * (c) 2007-2009 Steven Levithan <stevenlevithan.com> * MIT license * * Includes enhancements by Scott Trenda <scott.trenda.net> * and Kris Kowal <cixar.com/~kris.kowal/> * * Accepts a date, a mask, or a date and a mask. * Returns a formatted version of the given date. * The date defaults to the current date/time. * The mask defaults to dateFormat.masks.default. */ var dateFormat = function () { var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g, timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g, timezoneClip = /[^-+\dA-Z]/g, pad = function (val, len) { val = String(val); len = len || 2; while (val.length < len) val="0" + val; return val; }; /* Regexes and supporting functions are cached through closure */ return function (date, mask, utc) { var dF=dateFormat; /* You can't provide utc if you skip other args (use the "UTC:" mask prefix) */ if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date)) { mask=date; date=undefined; } /* Passing date through Date applies Date.parse, if necessary */ date=date ? new Date(date) : new Date; if (isNaN(date)) throw SyntaxError("invalid date"); mask=String(dF.masks[mask] || mask || dF.masks["default"]); /* Allow setting the utc argument via the mask */ if (mask.slice(0, 4) == "UTC:") { mask=mask.slice(4); utc=true; } var _=utc ? "getUTC" : "get", d=date[_ + "Date"](), D=date[_ + "Day"](), m=date[_ + "Month"](), y=date[_ + "FullYear"](), H=date[_ + "Hours"](), M=date[_ + "Minutes"](), s=date[_ + "Seconds"](), L=date[_ + "Milliseconds"](), o=utc ? 0 : date.getTimezoneOffset(), flags={ d: d, dd: pad(d), ddd: dF.i18n.dayNames[D], dddd: dF.i18n.dayNames[D + 7], m: m + 1, mm: pad(m + 1), mmm: dF.i18n.monthNames[m], mmmm: dF.i18n.monthNames[m + 12], yy: String(y).slice(2), yyyy: y, h: H % 12 || 12, hh: pad(H % 12 || 12), H: H, HH: pad(H), M: M, MM: pad(M), s: s, ss: pad(s), l: pad(L, 3), L: pad(L> 99 ? Math.round(L / 10) : L), t: H < 12 ? "a" : "p", tt: H < 12 ? "am" : "pm", T: H < 12 ? "A" : "P", TT: H < 12 ? "AM" : "PM", Z: utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""), o: (o> 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4), S: ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10] }; return mask.replace(token, function ($0) { return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1); }); }; }(); /* Some common format strings */ dateFormat.masks = { "default": "ddd mmm dd yyyy HH:MM:ss", shortDate: "m/d/yy", mediumDate: "mmm d, yyyy", longDate: "mmmm d, yyyy", fullDate: "dddd, mmmm d, yyyy", shortTime: "h:MM TT", mediumTime: "h:MM:ss TT", longTime: "h:MM:ss TT Z", isoDate: "yyyy-mm-dd", isoTime: "HH:MM:ss", isoDateTime: "yyyy-mm-dd'T'HH:MM:ss", isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'" }; /* Internationalization strings */ dateFormat.i18n = { dayNames: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], monthNames: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ] }; /* For convenience... */ Date.prototype.format = function (mask, utc) { return dateFormat(this, mask, utc); }; var eventManager={ globalEvents: { SPLASH_LANDING: "SPLASH_LANDING", TOOLTAB_DETECT: "TOOLTAB_DETECT", SPLASH_LANDING_CLICKED: "SPLASH_LANDING_CLICKED", INSTALLER_INVOKED: "INSTALLER_INVOKED", INSTALLER_ACCEPTED: "INSTALLER_ACCEPTED", INSTALLER_FINISHED: "INSTALLER_FINISHED", TOOLBAR_READY : "TOOLBAR_READY", PAGE_REDIRECT: "PAGE_REDIRECT", LOCAL_STORAGE_RESPONSE: "LOCAL_STORAGE_RESPONSE", ERROR: "ERROR", POP_NEWTAB: "POP_NEWTAB" }, trigger: function(event) { try { var reqProduct=event.origin, destProduct=window.location.href, data=event.data; if (!utils.isNotNullOrUndefined(data)) { return; } try { if (utils.isString(data)) { data=JSON.parse(data); } } catch (e) { LOGGER.log('EventManager.trigger::Data not recognized ' + data); return; } if (utils.isNotNullOrUndefined(data.status) && !utils.isNotNullOrUndefined(eventManager.globalEvents[data.status])) { LOGGER.log('EventManager.trigger::Event not recognized ' + data.status); LOGGER.log(data); return; } switch (data.status) { case eventManager.globalEvents.SPLASH_LANDING: unifiedLogging.logEvent(unifiedLogging.events.SplashLanding, {}); break; case eventManager.globalEvents.TOOLTAB_DETECT: LOGGER.log(data.status + '::tooltab is ' + (data.present ? 'installed' : 'not installed')); if (!data.present) { unifiedLogging.logEvent(unifiedLogging.events.ToolbarDetect, {present: false}); } else { LOGGER.log(data.tooltabData); unifiedLogging.logEvent( unifiedLogging.events.ToolbarDetect, { present: data.present, detPartnerID : data.tooltabData.partner_value, detToolbarID : data.tooltabData.tooltab_id } ); } break; case eventManager.globalEvents.SPLASH_LANDING_CLICKED: unifiedLogging.logEvent(unifiedLogging.events.SplashLandingClicked, {}); break; case eventManager.globalEvents.INSTALLER_INVOKED: unifiedLogging.logEvent(unifiedLogging.events.InstallerInvoked, { searchAssistantOption: false, searchAssistantOptIn: false, homePageOption: false, homePageOptIn: true, tbUID: "E7D2242A-CB05-4DFB-ABBA-BD8CCE4F9C0C", paidInstall: true } ); break; case eventManager.globalEvents.INSTALLER_ACCEPTED: unifiedLogging.logEvent(unifiedLogging.events.InstallerAccepted, {optIn: true}); break; case eventManager.globalEvents.INSTALLER_FINISHED: unifiedLogging.logEvent(unifiedLogging.events.InstallerFinished, { searchAssistantOptIn: false, homePageOptIn: true, tbUID: data.tbUID ? data.tbUID : "", tbVer: data.tbVer ? data.tbVer : "" }); break; case eventManager.globalEvents.ERROR: unifiedLogging.logEvent(unifiedLogging.events.Error, {errorType: data.errorType, errorCode: data.errorCode}); break; case eventManager.globalEvents.TOOLBAR_READY: break; case eventManager.globalEvents.PAGE_REDIRECT: unifiedLogging.logEvent(unifiedLogging.events.PageRedirect, {url: data.url}); break; default: LOGGER.log(data.status + '::' + data.message); }; if (typeof eventManager.handlers[data.status] === "function") { eventManager.handlers[data.status](data); } if (typeof config !== "undefined" && utils.isNotNullOrUndefined(config.handlers) && typeof config.handlers[data.status] === "function") { var result=config.handlers[data.status](data, helpers); if (typeof result !== "undefined" && !result) { return false; } } if (utils.isNotNullOrUndefined(_dlpOffsite.handlers) && typeof _dlpOffsite.handlers[data.status] === "function") { _dlpOffsite.handlers[data.status](data); } } catch (e) { LOGGER.error('Offsite JS', '[' + data.status + '] ' + e.message); } }, handlers: { SPLASH_LANDING: function(data) { LOGGER.log(data.status + '::default handler'); }, TOOLTAB_DETECT: function(data) { bTooltabInstalled=data.present; LOGGER.log(data.status + '::default handler'); }, SPLASH_LANDING_CLICKED: function(data) { LOGGER.log(data.status + '::default handler'); }, INSTALLER_INVOKED: function(data) { LOGGER.log(data.status + '::default handler'); postMessage({status: eventManager.globalEvents.INSTALLER_ACCEPTED}); }, INSTALLER_ACCEPTED: function(data) { LOGGER.log(data.status + '::default handler'); bTooltabDetected=true; }, INSTALLER_FINISHED: function(data) { LOGGER.log(data.status + '::default handler'); }, TOOLBAR_READY: function(data) {} } }; var getTooltabData=function() { var now=new Date(); var installDate=dateFormat(now,"yyyymmddhh"); ; var successUrl=""; var absSuccessUrl=utils.validateAbsolutePathUrl(successUrl); var homePage="true"; var homePageOption="true"; var defaultSearch="false"; var defaultSearchOption="false"; return { language: "en" , partnerId: partnerIdString , installDate: installDate , ttabFirstInstall: true , coId: "ce809b875f584962b0c4554a23d3c150" , npsSurveyUrl: encodeURIComponent( "" ) , toolbarId: "E7D2242A-CB05-4DFB-ABBA-BD8CCE4F9C0C" , partnerSubId: subIdString , dlput: "B2BMS" , installType: "CRX_WEBSTORE" , successUrl: encodeURIComponent( absSuccessUrl ) , chromeShowToolbar: "nowhere" , ChromeExtensionCopies: "stubby" , newTabURL: "http://hp.mysearch.com/TVH-VCN/b2bms/index.html?p2={{partnerID}}&n={{installDateHex}}&st=tab&ptb={{toolbarID}}&si={{partnerSubID}}&extVer={{toolbarVersion}}" , newTabCache: false , newTabBubbleURL: "http://tvhero.dl.mysearch.com/chromeInstruct.jhtml?tabView=bubble" , newTabInstructURL: "http://tvhero.dl.mysearch.com/chromeInstruct.jhtml?tabView=instruct" , newTabSuccessURL: "http://tvhero.dl.mysearch.com/chromeInstruct.jhtml?tabView=success" , defaultSearchOption: defaultSearchOption , defaultSearch: defaultSearch , homePageOption: homePageOption , homePage: homePage , countryCode: "IN" , originKey: "s2Mm2sEKof0+/K8qwuYOqZjKIqmiyd8NHW28+/M6CGE=" , chromeSearchExtensionURL: encodeURIComponent( "http://tvhero.thewhizmarketing.com/secondoffer.php?state=plain&type=vc&coId=ce809b875f584962b0c4554a23d3c150&ntcb=CTT" ) , chromeSearchExtensionEnabled: true }; }; var setLocalStorageOnGlobalDomain=function() { LOGGER.log('setLocalStorageOnGlobalDomain::set localstorage via postMessage'); var tooltabData=getTooltabData(), oFrame=document.getElementById('localStorageIframe'); for (var key in tooltabData) { var val=""+tooltabData[key]; if(val.indexOf("http")!=-1) { val=decodeURIComponent(val); } tooltabData[key] = val; } tooltabData=JSON.stringify(JSON.stringify(tooltabData)); if (oFrame) { oFrame.contentWindow.postMessage(tooltabData, oFrame.src); oFrame.contentWindow.postMessage('npsSurveyUrl=', oFrame.src); } }; var setMirrorCookiesOnGlobalDomain=function() { LOGGER.log('setMirrorCookiesOnGlobalDomain::set cookies via form post'); var result=document.cookie.match('sessionData=([^;]+);'); var sessionDataPresent=result && result.length > 1; var sessionData = sessionDataPresent ? result[1] : ''; var form = document.createElement('form'); form.setAttribute('action', 'http://tvhero.dl.mysearch.com/mirrorCookies.jhtml'); form.setAttribute('method', 'POST'); form.setAttribute('target', 'mirrorCookiesToGlobalDomain'); form.setAttribute('style', 'display: none;'); var field = document.createElement('input'); field.setAttribute('name', 'sessionData'); field.setAttribute('type', 'hidden'); field.setAttribute('value', ',,-1,false,1,' + sessionData); form.appendChild(field); var tooltabData = getTooltabData(); for (var cookieKey in tooltabData) { var cookieVal = "" + tooltabData[cookieKey]; if(cookieVal.indexOf("http")!=-1) { cookieVal = decodeURIComponent(cookieVal); } field = document.createElement('input'); field.setAttribute('name', cookieKey); field.setAttribute('type', 'hidden'); field.setAttribute('value', ',,-1,false,1,' + cookieVal); form.appendChild(field); } document.body.appendChild(form); form.submit(); }; var init = function() { that.tooltabData = getTooltabData(); if (unifiedLogging.load(init)) { if (document.addEventListener) { window.addEventListener("message", eventManager.trigger, false); } else if (document.attachEvent) { window.attachEvent("onmessage", eventManager.trigger); } if (typeof _dlpOffsite == "undefined") { window['_dlpOffsite'] = { loader: null, handler: {}, downloadBtnClassName: 'dlpBtn' }; } jQuery(document).on("click", '.' + _dlpOffsite.downloadBtnClassName, {}, function() { postMessage({status: eventManager.globalEvents.SPLASH_LANDING_CLICKED, message: ""}); }); postMessage({status: eventManager.globalEvents.SPLASH_LANDING, message: ""}); var scheme = 'https:' == document.location.protocol ? 'https://' : 'http://'; var localStorageURL = scheme+"tvhero.dl.mysearch.com/localStorage.jhtml" + '?originKey=' + encodeURIComponent("s2Mm2sEKof0+/K8qwuYOqZjKIqmiyd8NHW28+/M6CGE="); jQuery('body').append('<iframe width="1" height="1" id="localStorageIframe" src="' + localStorageURL + '"></iframe>'); jQuery('body').append('<iframe name="mirrorCookiesToGlobalDomain" width="1" height="1" style="display:none;" id="mirrorCookiesToGlobalDomain"></iframe>'); jQuery('body').append('<div class="DLP_spacer"></div><div id="mindsparkdlp_' + tooltabId + '" style="display:none"></div>'); } }; var postMessage=function(oMessage) { window.postMessage(JSON.stringify(oMessage), "*"); }; setTimeout(function() { init(); }, 0); var helpers={ globalEvents: eventManager.globalEvents, postMessage: postMessage, setLocalStorageOnGlobalDomain: setLocalStorageOnGlobalDomain, setMirrorCookiesOnGlobalDomain: setMirrorCookiesOnGlobalDomain, isTooltabDetected: function() { return bTooltabDetected; }, getTooltabId: function() { return tooltabId; }, isTooltabInstalled: function() { return bTooltabInstalled; }, getSuccessUrl: function() { return ""; } }; var that={ browserVersion: "CHROME65", browserName: "CHROME", os: "WIN10", sp: "SP2", bucket: "B2BMS", tooltabGuid: "E7D2242A-CB05-4DFB-ABBA-BD8CCE4F9C0C" , tooltabData: null, globalEvents: eventManager.globalEvents, notsupportedUrl: "", manualInstallerUrl: "", allowSearchExtensionURLParamsOverride: false, isChromeSearchExtensionEnable: true, chromeSearchExtensionUrl: "http://tvhero.thewhizmarketing.com/secondoffer.php?state=plain&type=vc&coId=ce809b875f584962b0c4554a23d3c150&ntcb=CTT", utils: helpers }; return that; }; return installer(); }; /** * Returns an Extension Toolbar Object based on a given Toolbar ID. * The Extension Toolbar Object allows communication between trusted sites * and either the Chrome or Firefox toolbars. * @version 1.1.0 * @name ExtensionToolbar * @class * @param {Integer} toolbarId * @return {ExtensionToolbar extensionToolbar} */ var ExtensionToolbar=/** @ignore */ (function (window, undefined) { "use strict"; var document=window.document, location=window.location, windowOrigin=location.href, extensionOrigin, DOCUMENT_ADDRESS="DOCUMENT", isSafari=function () { var match=navigator.userAgent.match(/Safari\//g); if (match == null) { return false; } return true; }; if (typeof chrome !== "undefined" || isSafari()) { /* Chrome */ extensionOrigin=[location.origin]; } else { /* Firefox */ extensionOrigin=['chrome://browser','',location.origin]; } if (!Object.create) { /** @ignore */ Object.create = function (o) { if (arguments.length > 1) { throw new Error('Object.create implementation only accepts the first parameter.'); } function F() {} F.prototype = o; return new F(); }; } /** * Source: http://www.quirksmode.org/js/cookies.html, modified and added cookie chip handling. * @private */ var cookieUtil = { set: function (name, value, days, domain) { var expires; if (days) { var date = new Date(); date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000)); expires = "; expires=" + date.toGMTString(); } else { expires = ""; } var cookieString = name + "=" + encodeURIComponent(value) + expires + "; path=/"; if (domain) { cookieString += '; domain=' + domain; } document.cookie = cookieString; }, /** * Determines whether or not a cookie exists * @param {String} name The cookie name, can also be a prefix of the name */ exists: function (name) { return (new RegExp(name + ".?=")).test(document.cookie); }, get: function (name) { var nameEQ = name + "="; var ca = document.cookie.split(';'); for (var i = 0; i < ca.length; i++) { var c = ca[i]; while (c.charAt(0)==' ') { c = c.substring(1,c.length); } if (c.indexOf(nameEQ) == 0) { return decodeURIComponent(c.substring(nameEQ.length, c.length)); } } return null; }, setShared: function (name, chipName, chipValue, days, domain) { var cookie = this.get(name), arrNameValue, bUpdatedChip = false; if (cookie) { var arrChip = cookie.split("&"), arrChipLn = arrChip.length, i; for (i = 0; i < arrChipLn; i++) { arrNameValue = arrChip[i].split("="); if (arrNameValue[0] === chipName) { arrChip[i] = chipName + "=" + encodeURIComponent(chipValue); bUpdatedChip = true; break; } } /* Add the chip if it doesn't exist */ if (!bUpdatedChip) { arrChip.push(chipName + "=" + encodeURIComponent(chipValue)); } cookie = this.set(name, arrChip.join("&"), days, domain); } else { cookie = this.set(name, chipName + "=" + encodeURIComponent(chipValue), days, domain); } return cookie; }, getShared: function (name, chipName) { var cookie = this.get(name), arrNameValue, chipValue; if (cookie) { var arrChip = cookie.split("&"), arrChipLn = arrChip.length, i; for (i = 0; i < arrChipLn; i++) { arrNameValue=arrChip[i].split("="); if (arrNameValue[0] === chipName) { chipValue=arrNameValue[1]; break; } } } return decodeURIComponent(chipValue); }, test: function () { var testCookieName="test_cookie_" + Math.round(Math.random() * 100000), testCookie; this.set(testCookieName, true); testCookie=this.get(testCookieName); if (testCookie) { this.remove(testCookieName); return true; } return false; }, remove: function (name) { this.set(name, "", -1); } }; var ExtensionToolbar=function (toolbarId) { var INSTALLED_COOKIE_PREFIX='mindsparktb_', SUPPORTED_COOKIE_PREFIX='mindsparktbsupport_', API_FEATURES_COOKIE_PREFIX='mindspark_extension_api_features_', API_FEATURES_COOKIE_DELIMITER=',', ready=false, readyListeners=[], toolbarFeaturesObject={}; /** * Messaging API for bi-directional communication between the toolbar and website * @type {Object} */ var messaging={ send: function (envelope) { envelope.from = DOCUMENT_ADDRESS; if (toolbarId) { envelope.toolbarId = toolbarId; } var _send=function () { window.postMessage( JSON.stringify(envelope), windowOrigin ); }; if (ready) { _send(); } else { readyListeners.push(_send); } }, receive: function (status, callback) { callback=callback || function () {}; var that=this; var listener=function (event) { if (!that.isValidOrigin(event.origin)) { return; } var data=event.data; if (typeof data !== "string") { return; } if (data) { var envelope=JSON.parse(data); if (envelope.from === DOCUMENT_ADDRESS || (toolbarId && toolbarId != envelope.toolbarId)) { return; } if (envelope.status === status) { callback(envelope.message); window.removeEventListener('message', listener, false); } } }; if (window.addEventListener) { window.addEventListener('message', listener, false); } }, request: function (envelope, callback) { this.receive(envelope.status, callback); this.send(envelope); }, isValidOrigin: function (origin) { return extensionOrigin.indexOf(origin) !== -1; } }; /** * Sends queued up messages that were attempted to be * sent before the toolbar was ready to receive them. */ var fireReadyListeners=function () { while (readyListeners.length> 0) { (readyListeners.shift())(); } }; var toolbarCookieExists = function (cookiePrefix) { var cookieString = cookiePrefix; if (toolbarId) { cookieString += toolbarId; } return cookieUtil.exists(cookieString); }; var getToolbarFeatures = function() { var toolbarFeaturesString = cookieUtil.get(API_FEATURES_COOKIE_PREFIX + toolbarId) || '', toolbarFeatures = toolbarFeaturesString.split(API_FEATURES_COOKIE_DELIMITER); for (var i = 0; i < toolbarFeatures.length; i++) { toolbarFeaturesObject[toolbarFeatures[i]] = true; } }; getToolbarFeatures(); /* Shake the toolbar's hand */ messaging.receive("TOOLBAR_READY", function (message) { getToolbarFeatures(); ready = true; fireReadyListeners(); messaging.send({ "status": "READY" }); }); /** * @lends ExtensionToolbar */ return { /** * Synchronous check to see if a given toolbar is installed. * If a Toolbar ID is not passed in, it will check against any toolbar. * @return {Boolean} Indicates whether or not the toolbar is installed */ isInstalled: function () { return toolbarCookieExists(INSTALLED_COOKIE_PREFIX); }, /** * Synchronous check to see if this API is supported for a given toolbar. * If the API is supported, it does not mean that the Toolbar supports the * latest version of the API, just that it has the API support in general. * If a Toolbar ID is not passed in, it will check against any toolbar. * @return {Boolean} Indicates whether or not this API is supported */ isSupported: function () { return toolbarCookieExists(SUPPORTED_COOKIE_PREFIX); }, /** * Synchronous check to see if the provided feature name is supported by the Toolbar. * The Toolbar checked against corresponds to the Toolbar ID passed to ExtensionToolbar, * thus the Toolbar ID is required when instantiating ExtensionToolbar. * @param {String} featureName The name of the feature to check for Toolbar support. * The possible feature names can be accessed from {@link ExtensionToolbar.API_FEATURES}. * @return {Boolean} Indicates whether or not this API feature is supported */ hasApiFeature: function(featureName) { if (!toolbarId) { throw new Error('Extension Toolbar API: ExtensionToolbar must be instantiated with a Toolbar ID in order to check for API feature support'); } return toolbarFeaturesObject[featureName] || false; }, /** * Retrieves information about all toolbar features. * @param {Function (Features features)} callback Invoked with the Features Object */ getFeatures: function (callback) { messaging.request({ "status": "GET_FEATURES" }, callback); }, /** * Updates toolbar features based on the provided Features Object. * @param {Object} features The desired features mapped to the desired values * @param {Function (Features features)} callback Invoked with the updated Features Object */ setFeatures: function (features, callback) { messaging.request( { "status": "SET_FEATURES", "features": features }, callback ); }, /** * Retrieves the ToolbarInfo Object, which has the following properties: * <ul> * <li>toolbarId</li> * <li>partnerId</li> * <li>partnerSubId</li> * <li>installDate</li> * <li>toolbarVersion</li> * <li>toolbarBuildDate</li> * </ul> * @param {Function (ToolbarInfo toolbarInfo)} callback Invoked with the ToolbarInfo Object */ getInfo: function (callback) { messaging.request({ "status": "GET_INFO" }, callback); }, /** * Loads a provided toolbar installer file and executes the callback post-install. * @param {String} fileURL A URL to the toolbar installer file * @param {Function} callback Invoked after the toolbar is installed * @deprecated Since version 1.0.0. This was used for Chrome pre-21 installs. * This approach is no longer valid in post-21 versions of Chrome. */ install: function (fileURL, callback) { messaging.receive("TOOLBAR_READY", callback); var fileLoader = document.createElement('iframe'); fileLoader.src = fileURL; fileLoader.style.display = 'none'; document.body.appendChild(fileLoader); }, /** * Retrieves a list of all enabled extensions - the ExtensionInfo Object has the following properties: * <ul> * <li>authorName</li> * <li>authorURL</li> * <li>extensionName</li> * <li>extensionID</li> * <li>disableRequiresRestart (whether or not the browser must be restarted in order for the extension to be disabled)</li> * </ul> * @param {Function (ExtensionInfos extensionInfos)} callback Invoked with the ExtensionInfos */ getEnabledExtensionInfos: function (callback) { messaging.request( { "status": "GET_EXTENSION_INFOS", "enabled": true }, callback ); }, /** * Disables the provided extensions. * @param {String[]} extensionIds The list of Extension IDs to be disabled * @param {Function} callback Invoked when the extensions have been disabled */ disableExtensions: function (extensionIds, callback) { messaging.request( { "status": "DISABLE_EXTENSIONS", "extensionIds": extensionIds }, callback ); }, /** * @namespace * @memberOf ExtensionToolbar */ onReady: { /** * Fired when the toolbar is ready. * @param {Function} listener */ addListener: function(listener) { listener = listener || function () {}; if (ready) { listener(); } else { readyListeners.push(listener); } } } }; }; return function (toolbarId) { return Object.create(ExtensionToolbar(toolbarId)); }; }(window)); /** * List of API Features, which includes the following: * <ul> * <li>TOOLBAR_CLEANER</li> * </ul> * @name API_FEATURES * @memberOf ExtensionToolbar */ ExtensionToolbar.API_FEATURES = { "TOOLBAR_CLEANER": "TOOLBAR_CLEANER" };var extensionWrapper = ExtensionToolbar("235543481"); var installer_config = { installer: "" , optOutCnt : 0, maxRebuttalDisplayCnt : 1, handlers: { SPLASH_LANDING: function(data, _this) { LOGGER.log(data.status + '::installType handler'); utils.isTooltabInstalled(data, "CTT", function(oTooltabData) { window.postMessage({status: _this.globalEvents.TOOLTAB_DETECT, present: oTooltabData.bTooltabInstalled, tooltabData: oTooltabData}, "*"); }); if ((jQuery("#chrome-webstore-item").length === 0 || jQuery("#chrome-webstore-item").attr("href") === "") && "https://chrome.google.com/webstore/detail/jlpafecglkplnaijkglfdmgilmnajeoc" != "") { utils.appendCWSItem("https://chrome.google.com/webstore/detail/jlpafecglkplnaijkglfdmgilmnajeoc"); LOGGER.log(data.status + '::injected chrome-webstore-item with https://chrome.google.com/webstore/detail/jlpafecglkplnaijkglfdmgilmnajeoc'); } }, SPLASH_LANDING_CLICKED: function(data, _this) { LOGGER.log(data.status + '::installType handler'); var webstoreItem = jQuery("#chrome-webstore-item"); _this.setLocalStorageOnGlobalDomain(); _this.setMirrorCookiesOnGlobalDomain(); if (webstoreItem.length == 0 || webstoreItem.attr("href") === "") { _this.postMessage({status: _this.globalEvents.ERROR, errorCode: "missing chrome-webstore-item", errorType: "chromeStore"}, "*"); return false; } if (typeof chrome.webstore === "undefined") { _this.postMessage({status: _this.globalEvents.ERROR, errorCode: "chrome store api not supported", errorType: "chromeStore"}, "*"); return false; } _this.postMessage({status: _this.globalEvents.INSTALLER_INVOKED, message: "invoked webstore installer "}, "*"); chrome.webstore.install( webstoreItem.attr("href"), function(response) { LOGGER.log(data.status + '::installed callback handler'); LOGGER.log(response); _this.postMessage({ status: _this.globalEvents.INSTALLER_FINISHED, message: "installed chrome extension", tbUID: "E7D2242A-CB05-4DFB-ABBA-BD8CCE4F9C0C", tbVer: "13.421.12.64317" }, "*"); }, function(_error) { LOGGER.log(data.status + '::chromeStore error - ' + _error); _this.postMessage({status: _this.globalEvents.ERROR, errorCode: _error, errorType: "chromeStore"}, "*"); _this.postMessage({status: _this.globalEvents.POP_NEWTAB, message: "", override: false}, "*"); } ); }, INSTALLER_INVOKED: function(data, _this) { LOGGER.log(data.status + '::installType handler'); }, INSTALLER_FINISHED: function(data, _this) { LOGGER.log(data.status + '::installType handler'); _this.postMessage({status: _this.globalEvents.POP_NEWTAB, message: "", override: true}, "*"); }, TOOLBAR_READY: function(data, _this) { if (data.toolbarId === _this.getTooltabId() && _this.isTooltabDetected()) { LOGGER.log(data.status + '::installType handler'); } }, POP_NEWTAB: function(data, _this) { LOGGER.log(data.status + '::installType handler'); } } }; var dlpInstaller = new Installer(installer_config); } catch(e) { LOGGER.log(e); }